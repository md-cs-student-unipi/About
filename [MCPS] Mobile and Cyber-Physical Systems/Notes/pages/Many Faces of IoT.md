Here are some points taken from the paper. [[manyfaceshigligted.pdf]]
With systems based on the publish/subscribe interaction scheme,
subscribers register their interest in an event, or a pattern of events, and are
subsequently asynchronously notified of events generated by publishers.
This paper factors out the common
denominator underlying these variants: full decoupling of the communicating entities
in time, space, and synchronization. 


## Burden
To reduce the burden of application designers, the glue between the different entities in such large-scale settings should rather be provided by a dedicated middleware infrastructure, based on an adequate communication scheme. The publish/subscribe interaction scheme is receiving increasing attention and is claimed to provide the loosely coupled form of interaction required in such large-scale settings.

Subscribers have the ability to express their interest in an event, or a pattern of events, and are subsequently notified of any event generated by a publisher, which matches their registered interest. An event is asynchronously propagated to all subscribers that registered interest in that given event.

## Basic Interaction Scheme
In other terms, in the publish/subscribe interaction, producers publish information on a software bus, which serves as an event manager. On the other hand, consumers subscribe to the specific information they want to receive from that bus. This information is commonly referred to as an event, and the process of delivering it is known as a notification.

The basic system model for publish/subscribe interaction (Figure 1) is built upon an event notification service. This service is responsible for storing and managing subscriptions, as well as efficiently delivering events. It provides the necessary infrastructure for handling the dynamic nature of subscriptions and ensuring timely and reliable event delivery.

![[Pasted image 20230620181912.png]]


Subscribers register their interest in events by typically calling a `subscribe()` operation on the event service, without knowing the effective sources of these events.
The symmetric operation `unsubscribe()` terminates a subscription.

To generate an event, a publisher typically calls a `publish()` operation. The event service propagates the event to all relevant subscribers. As a result, the event service can be viewed as a proxy for the subscribers, ensuring that the events are distributed to the appropriate recipients.

Publishers also often have the ability to advertise the nature of their future events through an `advertise()` operation.


## Space Decoupling
Space decoupling: The interacting parties do not need to know each other.
The publishers publish events through an event service, and the subscribers receive these events indirectly through the event service. The publishers do not usually hold references to the subscribers.
Subscribers do not usually hold references to the publishers, neither do they know how many of these publishers are participating in the interaction.

## Time Decoupling
Time decoupling: The interacting parties do not need to be actively participating in the interaction at the same time.
The subscriber might get notified about the occurrence of some event while the original publisher of the event is disconnected.

## Synchronization decoupling
Synchronization decoupling: Publishers are not blocked while producing events, and subscribers can get asynchronously notified (through a callback).
Publishers and subscribers do not interact in a synchronous manner and therefore their interactions are not synchronous.
**Decoupling the production and consumption of information increases scalability by removing all explicit dependencies between the interacting participants.**
Well adapted to distributed environments that are asynchronous by nature, such as mobile environments.

# The siblings: Pub/Sub variations
Subscribers are usually interested in particular events or event patterns, rather than all events. The different ways of specifying the events of interest have led to several subscription schemes. In this section, we compare the two most widely used schemes, namely topic-based and content-based publish/subscribe, as well as the recently proposed type-based subscription scheme.

## Topic based
The earliest publish/subscribe scheme was based on the notion of topics or subjects.
Participants can publish events and subscribe to individual topics, which are identified by keyword.
Consequently, subscribing to a topic T can be viewed as becoming a member of a group T, and publishing an event on topic T translates accordingly into broadcasting that event among the members of T.
In practice, topic-based publish/subscribe systems introduce a programming abstraction that maps individual topics to distinct communication channels.
Every topic is viewed as an event service of its own, identified by a unique name, with an interface offering `publish()` and `subscribe()` operations.

The topic abstraction is easy to understand and enforces platform interoperability by relying only on strings as keys to divide the event space. Various systems have proposed additions to the topic-based scheme. One useful improvement is the use of hierarchies to orchestrate topics. While group-based systems offer flat addressing, where groups represent disconnected event spaces, nearly all modern topic-based engines offer a form of hierarchical addressing. This allows programmers to organize topics according to containment relationships.

Most systems allow topic names to contain wildcards, Wildcards offer the possibility to subscribe and publish to several topics whose names match a given set of keywords. This includes subscribing to an entire subtree or a specific level in the hierarchy.


## Content-Based
**The topic-based publish/subscribe variant represents a static scheme which offers only limited expressiveness.**
**The publish/subscribe variant improves on topics by introducing a subscription scheme based on the actual content of the considered events.** In other terms, events are not classified according to some predefined external criterion (e.g., topic name), but according to the properties of the events themselves.

Consumers subscribe to selective events by specifying filters using a subscription language. The filters define constraints, usually in the form of name-value pairs of properties and basic comparison operators (=, <, ≤, >, ≥), which identify valid events. Constraints can be logically combined (and, or, etc.) to form complex subscription patterns. Some systems, like the Cambridge Event Architecture (CEA) [Bacon et al. 2000], also provide for event correlation: participants can subscribe to logical combinations of elementary events and are only notified upon occurrence of the composite events.

Subscription patterns are used to identify the events of interest for a given subscriber and propagate events accordingly. For subscribing, a variant of the `subscribe()` operation is provided by the event service, with an additional argument representing a subscription pattern.
There are several means to represent such patterns:
* strings
* template objects: When subscribing, a participant provides an object `t`, which indicates that the participant is interested in every event that conforms to the type of `t` and whose attributes all match the corresponding attributes of `t`, except for the ones carrying a wildcard (null).
* executable code: Subscribers provide a predicate object capable of filtering events at runtime.  Executable code is not widely used in practice because the resulting filters are extremely hard to optimize.
**The content-based scheme enforces a finer granularity than a static scheme based on topics.** To achieve the same functionality with topics, the subscriber would either have to filter out irrelevant events, or topics would need to be split into several subtopics—one for each company (and recursively several subtopics for different price "categories"). The first approach leads to an inefficient use of bandwidth, while the second approach results in a high number of topics and an increased risk of redundant events.

## Type-based
Topics usually regroup events that present commonalities not only in content but also in structure. This observation has led to the idea of replacing the name-based topic classification model by a scheme that filters events according to their type.

The notion of event kind is directly matched with that of event type. This enables a closer integration of the language and the middleware. Moreover, type safety can be ensured at compile-time by parameterizing the resulting abstraction interface by the type of the corresponding events (without any type cast in the resulting code).

![[Pasted image 20230620183708.png]]

**Subtyping can be used to subscribe to both stock quotes and requests.**
It is important to notice that type-based publish/subscribe can lead to a natural description of content-based filtering through public members of the considered event type, while ensuring the encapsulation of these events. This is achieved in our example of Figure 15 by declaring only **private data members and enforcing their access through public methods.**
