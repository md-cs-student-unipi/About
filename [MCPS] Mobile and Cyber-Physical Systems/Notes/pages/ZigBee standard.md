It is a standard for wireless sensor networks, allows to build large network covering large domain, it does not use TCP/IP, but it provides support to connect devices to the rest of the internet, allowing a ZigBee network to be connected to the internet. ZigBee can be considered an IoT standard.

The practical scope of this standard is, in a certain sense, limited in scope. It tried to enter the healthcare market, but it was dominated by Bluetooth. Even though ZigBee is not the most widely used program, it is still widely used, including in end-user programs. ZigBee is more complex than other standards.

#### Requirements of the standard:
1.  Build an independent network of devices that can self-construct with minimal or no manual intervention and without the need for maintenance, limited or no human intervention.
2.  Long battery life (e.g., 10 years).
3.  Low data rate (needs to guarantee very long battery life, so there is a trade-off with good performance).
4.  Interoperability: all devices developed with the ZigBee standard must be compatible with each other.

#### Features of the standard:
1. Can be used globally: since it is a wireless standard, the law decides the frequencies reserved for a certain use. On the private use frequencies, there are constraints on the power. For example, on ZigBee and Bluetooth, you cannot transmit with high power, or it would disrupt other signals.
2. Reliable and self-healing: reliable as the internal method of communication is reliable. Self-healing comes as a byproduct of redundancy that can be set up in that network.
3. Support a large number of devices, using the concept of multi-hop networks.
4. Easy to deploy and comes with built-in security features.

![[Pasted image 20230310150309.png]]
[[MPCS/pages/802.15.4]] is the standard that builds the stack at the MAC layer and Physical Layer, made in 2003. The ZigBee alliance defines the Network layer and the Application Layer. In the first layer, there is a Transportation layer, made in 2004.

# 802.15.4
802.15.4 is an infrastructure-less protocol. There are no access points, and devices communicate end to end. It is short-range and can operate in the same frequencies of WiFi 802.11 and Bluetooth 802.15.1, because they perceive each other as noise, in fact, the frequencies are used in orthogonal ways.
The data rate advertised **worldwide** is 250 kbps, but it is difficult or impossible to achieve.
To reach this data rate one must use the brands of 2400-2484.5 MHz worldwide.

In general the specifics of it are:
* low-rate Wireless Personal Area Network (PAN) specification for physical and MAC layers
* Infrastructure-less
* Short range
* Star and peer-to-peer topologies supported
* Licence-free frequency band. In Europe the frequencies are of 868â€“868.6 MHz (above there are the worldwide ones).

# ZigBee layers
![[Pasted image 20230310151026.png]]

**Components of the application layer:**
* Application Framework: contains up to 240 APO (APplication Object), where each APO is a user-defined ZigBee application.
* ZigBee Device Objects: provides services to let the APO organize into a distributed application.
* APplication Support sublayer (APS): provides data and management services to the APO and ZDO

ZigBee is built on top of the MAC layer 802.15.4. The application layer has a transport layer that is much lighter than TCP. Then we have the ZigBee Device Object, which provides the main services to organize the application into a distributed application. The behavior of the standard is implemented in the ZDO.

For example, the connection to an existing network must not be implemented by the user. Instead, it is the ZDO that handles it. The implementation is done by the manufacturer of the ZigBee devices. Manufacturers provide the device, embed it in a shell, and deliver it.

If one uses an Arduino to create a solution, this stack must be programmed on its own to implement all the device's behaviors.

### Primitives
Each service is specified by a set of primitives of four generic types:
- request: invoked by the upper layer to request for a specific service
- indication: generated by the lower layer and directed to the upper layer to notify the occurrence of an event related to a specific service.
- response: invoked by the upper layer to complete a procedure previously initiated by an indication primitive.
- confirm: generated by the lower layer and directed to the upper layer to convey the results of one or more previous service requests.

Services may not use all the for primitives actually.
![[Pasted image 20230310154700.png]]

The communication goes from a request on device 1, going down to layer n-1. Then in device 2, the request becomes an indication, going as an indication to layer n+1. Sometimes not all the primitives are used.
![[Pasted image 20230311115551.png]]

The Application object at the physical layer needs physical transmission. So the data units are present at each level. The PPDU stands for physical **protocol** data unit and is the one exchanged from physical to physical.
![[Pasted image 20230311115541.png]]

## Network Layer
FFD: Full functional devices, consisting in routers and network coordinators. 
RFD: are end devices, basically a reduced functional device.

At the network layer, devices are not the same. We identify three types of devices at the network layer:
1. Network Coordinator: Since ZigBee does not have an infrastructure with Access Points deployed statically, here it is a device that takes the role of creating the network, making decisions, and interfacing with the rest of the network. In general, the coordinator is the one creating the network.
2. Router: if the network is large, the router forwards the message in that. From the PoV of capabilities, routers and coordinators have the same.
3. End devices: They cannot communicate with the rest of the network. They must be attached to routers or coordinators to be part of it. The reason to have separate types of devices is to support low power devices. Implementing as end devices allows not implementing all the standards, while routers must implement all.

### Topologies
![[Pasted image 20230311115421.png]]

1.  In ZigBee, the Star topology is commonly used, where the coordinator acts as the central hub and all communications pass through it. End devices are connected directly to the coordinator, and routers are used to extend the range of the network.    
2.  In the Tree topology, there is no direct communication with the coordinator. Instead, routers are used to relay the packets from the source end device to the destination end device via the coordinator. Routers in the Tree topology have either two leafs - other routers or end devices - or one leaf.
3.  The Mesh topology is a more flexible option that allows for multiple endpoints to connect via routers. Unlike the Tree topology, there is no tree-like structure in a Mesh network. Instead, data packets can take multiple paths to reach their destination, and each node can act as a router to forward packets to other nodes in the network. Mesh networks are highly resilient and can self-heal in the event of a node failure.

The network layer provides the following services:
-   data transmission using unicast or multicast.
-   network initialization.
-   device addressing.
-   managing routes and supporting routing.
-   managing connections and disconnections to devices.

A ZigBee network is formed incrementally. The join mechanism allows devices to connect to the coordinator one after the other, and then a network with an arbitrary topology is formed.

The network layer uses Request, Indication, and Confirm primitives without Response, and sometimes the Indication primitive is missing.
Network discovery allows discovery of other ZigBee networks to connect to.

GET/SET allows for reading and setting an internal parameter of the network layer, acting locally on the network layer.

Connecting to a ZigBee network can be done in two ways:
1.  Being a coordinator, accepting requests, and then coordinating.
2.  Being a router or an end-device and connecting to the coordinator device.

The role of a device is decided at compile time, meaning that we decide what to implement on each device (coordinator, gateway), then put the device in a shell, and deliver it.

The first thing a device can do in ZigBee is either to join an existing network or create a new one. Non-coordinator devices will try to join a network, while coordinators will attempt to create one.

### Set up
In ZigBee, each device can only be part of one independent network. 
The application layer runs code and tries to find network information by invoking a network information request to the network layer. The network layer implements a single network on multiple frequencies, but only on one channel. To set up a channel, a set of frequencies is chosen that is not too noisy and free to establish a network.

In ZigBee, there are 16 frequencies in the 2.4 MHz band. The MAC layer looks for a channel with low noise levels to establish a network, performing an energy scan. It measures the amount of energy in each channel and returns a report on the state of the channels, allowing the network layer to choose the optimal channel for establishing the network.

#### Create a network
The process of forming a network involves creating a Personal Area Network (PAN) over a particular channel.

The **coordinator takes address 0(0x0000)**, while other devices take dynamic addresses. Zigbee devices use both 64-bit IEEE addresses and 16-bit network addresses for addressing. The IEEE address is unique to each device, while the network address is assigned dynamically by the coordinator. The network layer is responsible for maintaining a table of addresses for each device in the network, and it can allocate or de-allocate network addresses as necessary.


#### Process of Network formation:
![[Pasted image 20230311113603.png]]
The coordinator assigns itself the 16-bit network address 0x0000.
0) From Application layer send a NETWORK-FORMATION.request to the Network layer. 
1) Phase 1: The Zigbee device must first perform an energy scan to determine the channels that are free to use. The network layer performs the initial scan by asking the MAC layer to do with a SCAN-request. **This is needed to look for a channel that does not conflict with other existing networks**, so with the one a lowest noise. The MAC layer sends a SCAN.confirm to the Network layer as response with a list of the **channels with the strongest signal**.
2) Phase 2: The Network layer sends another SCAN.request, specifying the **channel with the strongest signal**, for which then the MAC layer performs an **active scan**, finding if there are any networks in the neighbourhood. It is done to ensure that any coordinators in the channel are discovered. The active scan helps to find a device communicating over that channel, and if no packets (**beacon frame**) are transmitted, it indicates that the channel is free.
3) Then the MAC layer sends a SCAN.confirm then **returns the list of all the available channel for network formation**.
4) The Network layer selects a channel and **select a PAN identifier which is not already in use by other PANs**.

Once a coordinator creates a network over a channel, it sends beacons to indicate that a network exists. A beacon contains an ID, PAN ID, and other parameters, and the layer takes note of the noises paired with the ID to find a channel where it can create a network.

#### Join
Joining a Zigbee network can be done in two ways:
1.  Join by association: The device initiates the join to the existing network  by sending an association request to a router or coordinator.    
2.  Direct join: Requested by a router or coordinator to ask a device to join its PAN, so there must be an operator choosing what device to connect.

##### By association
On the client side, to join a network:
1.  The client should find if there are existing networks around, and on what channel, then ask them to connect. The application layer, which is provided by the provider, must only be configured. To do so, the client asks to the network layer to do a NETWORK.DISCOVERY.request. The Network layer will forward a SCAN.request to the MAC layer that will perform the **ACTIVE SCAN**.
2.  After the active SCAN, the MAC layer sends a SCAN.confirm to the Network layer, the Network layer in turn sends a NETWORK-DISCOVERY.confirm, so the application layer arrives *the list of all neighbor networks is presented*.
3.  It is not up to the network layer to decide which network to join. Choosing the appropriate network will require a decision of a technician. These are the networks available, and the application layer selects a PAN (usually an operator). So the technician selects a PAN.    
4.  With the JOIN.request, you ask for a network address, but you do not have one. Usually you need one to communicate with a network, but there is an exception to do the join. So the JOIN.request, goes from Application layer to Network layer. The JOIN.request is called with parameters:
	-  PAN identifier of the selected network
	-  Flag indicating weather it is joined as router or end device
5. The JOIN.request primitive in the network layer select a **parent node** P in the PAN from the neighbourhood:
	- In star topology: P is the coordinator and the device will join as end device
	-  In tree topology: P is **a coordinator or a router, the device will join as router or as end-device**
6. The Network layer sends an ASSOCIATE.request to the MAC layer, which starts the Association protocol, allowing to **obtain the 16-bits short address**. The MAC layer will do the JOIN, and when doing so, you will receive a beacon from the coordinator of a network you are connecting to (if in the same area or get the beacon from a router forwarding here). Then the MAC layer sends the ASSOCIATE.confirm to the Network layer, which contains the address. Finally the Network layer sends the JOIN.confirm to the Application layer.
7. From  there on the Network layer will use the 16-bits network address to communicate over the network.
    
![[Pasted image 20230311113139.png]]


All the layers must be informed of the join, and all the layers must allocate resources and take notes of the networks, not just the MAC.

-   MAC layer should do the low-level communication.
-   Network layer handles routing and higher level of communication.

In fact, the JOIN protocol is at the Network layer, while the ASSOCIATE is on the MAC layer.

This protocol is executed by the router and end device exactly the same way. There will be on the side of the coordinator another JOIN protocol.

Even in a Tree topology, the routers will forward the beacon to allow to connect to a network. You can decide what routers, in the multi-hop network, to use. In general, use the router closer to the coordinator, which can be the parent.

When you JOIN, you specify:

-   PAN identifier of the selected network
-   A flag indicating whether it joins as a router or an end device.

If you join, you get two types of network addresses:

-   End device network address
-   Router network address

Before performing the JOIN request, you specify if you are executing as a router or an end device. The parent (being a router or the coordinator, from the topology) will decide for you the network address. Joining as a coordinator or not does not change much as JOIN.


## Using the network address instead of the MAC
When you transmit something:
* you have the headers for multiple levels.
The size of the headers are massive.
ZigBee does not use the **MAC addresses but just the Network address**, this comes at a cost to do this, which we see as we need a binding table in the coordinator, but it allows to send lighter weight messages.


# Application Layer
Components are:
Application framework: light TCP, includes the set of Application Objects APO.
* Zigbee device Object(ZDO):  manages the application services
* Application Support Sublayer: provides data, binding and discovery services

Zigbee Device Object: it includes the application logic, with device able to understand different logics.
Application Support Sublayer

![[Pasted image 20230311111459.png]]


### Application Framework
To address an Application Profile Object (APO), you need to give it an ID. There are 240 possible APO values, corresponding to an application endpoint. The value 0(0x0000) is reserved for ZDO (Zigbee Domain Object).


Each APO in the network is uniquely identified by its endpoint address and *the network address of its **hosting device**.

You can query APOs with the Key Value Pair (KVP) data service, which allows you to query the key or value from sensors. APOs may also allow for more complex states and interactions.
(The cluster library now includes KVP)


You may have devices with multiple switches (e.g. lights) and bulbs, and you need to decide how to connect them.

One approach is to create an APO for each switch (two APOs for each light switch) and an APO for the light bulb. Then, a switch can be connected to one or multiple other APOs. To implement this, communication for those devices must be implemented in the MAC layer, Network Layer, and Application Layer.



In this sample application, there are:
* APO 5B
* APO 6B
* APO 8B
Which have the single attribute:
* bulb status: on/off

Then we have APO 10 and APO 25 which are switches and are configured as *clients **at** the application layer*.
The attributes of APO 5B, 6B and 8B can be set remotely from the APO 10A and 25A.

![[Pasted image 20230311110353.png]]

# Transport Layer: APPLICATION SUPPORT SUBLAYER  (APS)

The APS is a lightweight transport layer that offers packet-level transport without creating channels, unlike TCP. It also provides an optional acknowledgment mechanism.
The acknowledgements are end to end.
Furthermore, the APS can filter out packets for non-registered endpoints. The local binding table, local groups, and local address map are managed by the management system.
So in general APS provides:
* Data service as a light transport layer,  filtering out the packet to non registered endpoints and profiles not matching and generating end-to-end acknoweledgements
* Management: with local binding table, local group table, local address map.
## Application Protocol Interface (APO): Endpoints

The APO allows applications that use different protocols to communicate with each other, enabling them to be part of the same larger application. Endpoint IDs range from 1 to 240.

A ZigBee device can run multiple applications, one for each APO, where endpoints are seen as virtual wires connecting applications, which are equivalent to Unix sockets.

The endpoint allow for several profiles, devices and control points to co-exist withing a single node.
### Clusters
Clusters are protocols at the application level that define specific device behavior. Although optional, to ensure device compliance with the Cluster Library and the standard, they must be implemented in accordance with the cluster specified in the cluster library. **Clusters can be messages in simpler cases, but in more complex cases, they can define specific device behavior.**

**Cluster defines an interaction protocol, so informally a cluster provides access to a service/functionality of an application object.**

A cluster defines a set of attributes to read or write and specifies commands and actions for the devices. Clusters can be combined to create a basic application that specifies a particular behavior.

* commands cause actions on a device
* attributes show the state of a device in a given cluster

To determine the actions to take when receiving a message, a cluster identifier must be provided. Cluster identifiers use 16-bit identifiers, and although they may seem large, they are extensively used within specific application areas such as industry or agriculture. The scope of the identifiers varies based on the application area.

For example, a cluster identifier can be used to specify the action of turning on a light.

**Cluster ID have a meaning withing a given profile**
### General domain 
This is a type of domain that is independent of the application being considered, whether in smart industry, smart city, or agriculture, etc. This cluster does not belong to a specific profile but rather a generic profile.

Basic Cluster, for example, determines the version of the ZigBee protocol being implemented.

Power Configuration Cluster 0x0001 provides information about the device, such as whether it has a battery or is plugged in. By connecting to this cluster of a device, one can obtain information about its power source.

Temperature Configuration Cluster 0x0002 is not a thermometer cluster, but rather is used to monitor the internal temperature and to read or set the temperatures of the specific cluster, as specified in the specification.
![[Pasted image 20230310171546.png]]
## Application Profiles
**Cluster ID have a meaning withing a given profile**
Application profiles are collections of clusters specific to certain application domains. There are parts of the specification that are specific to ZigBee, such as the join process. Additionally, to comply with the standard, there are other parts of the specification. Several documents (written by the ZigBee alliance) contain application profiles with cluster libraries, which are lengthy to write for all application domains. One example is home automation.

An identifier must be unique and be used to call the behavior of an application profile and its associated cluster.
Application profiles are represented by 16-bit numbers, but proprietary solutions are also possible.

A set of addresses:
* is used to specify standard profile
* can be used to define proprietary profile (non standard)

Connecting to a proprietary ZigBee network is possible if there are no security checks and they allow it. You may call general domain clusters and even interpret some behaviors, but if you receive packets with a proprietary application profile, you may not understand them. So while you can do some things as part of the network, you cannot do everything.

A ZigBee network may contain application objects with multiple profiles. In the standard, there is no limitation on the number of application objects and profiles that can be responded to, even multiple.


![[Pasted image 20230310171559.png]]


### Device IDS
From the perspective of the standard and the device, the Device ID is not necessary. However, for human operators, it is essential as the devices themselves cannot identify what they are
- the IDs are simply numbers mapped to descriptions of the devices
 Human operators rely on the descriptions provided by the IDs to identify the devices, but the devices themselves do not require this information.
ZigBee discovers services in a network based on *profile ID and cluster ID*, not on **device ID**.

# (Application Support Sublayer)APS services
APS: it is a software on a device. It provides services for:
* APOs
* ZDO: ZigBee Device Objects (which provide services to let the APOs to organize into a distributed application)

The APS data service enables the exchange of messages between two or more devices withing a network, where the data service is defined in terms of the primitives:
* request(send)
* confirm (returns the status of the transmission)
* indication (receive)

For example we have the APS of a device that is a switch, and sends an APS-DATA.request
![[Pasted image 20230310173413.png]]
An APS-Data.request is received and is sent until an APS-ACK is received.

There are some group table, where there is a forwarding to all APO in the group table.
There are APO to move and join a group as broadcast groups messaging basically.
The group management provides:
* services to build and maintain groups of APOs
Each APO in the group is identified by the pair:
* network address
* endpoint

The ADD-GROUP primitive is used to add an APO to a group.
The REMOVE-GROUP primitive to remove an APO from a group.
The primitives take the group number and the endpoint number, **in case the endpoint numbers does not exist, it creates it**. 
Information about groups is in a group table in the APS.


## Connection to a network
Once connected to a network, a device receives an address and uses it for communication. For example, a thermometer may receive address 100, while a thermostat receives address 200. If there is a power outage, the device goes down, and the coordinator creates a new network, the devices may receive different addresses, such as 70 and 220.

Since we do not have the MAC address, we cannot identify devices using the same address. This creates a challenge when managing power shortages. The ZigBee protocol addresses this challenge by using binding. Binding creates a permanent association between APOs during network configuration, which is then stored in the APS. By creating a bind between APOs and APS, the binding allows the source to connect to the destination.

The APO does not need to know which other APO it is connecting to. It only needs to know the value of the switch but not where it needs to connect. Binding allows the system to maintain connections and continue to function even in the event of power outages or device failures.

## APS binding

The APS uses the binding table, network address, and endpoint address to locate the destination endpoint and network address by referring to the binding table.
Binding allows an endpoint on a node to be connected (bound) to one or more endpoints on other nodes, **binding is unidirectional and can be performed by the ZDO of the coordinator**

![[Pasted image 20230311103547.png]]
The ZDO of the coordinator must create a bind of the network address with the network address of another device. This process is necessary to enable communication between devices. Once a bind is created, the devices can communicate with each other, and the APS uses the binding table to locate the destination device.

### Direct vs indirect addressing.

In direct addressing, you define the addresses pair \<destination endpoint, destination address\>, whereas in indirect addressing, the message is sent, and the network finds the receiver.
Direct addressing is not suitable for extremely simple devices
While Indirect addressing exploits binding tables

# Creating a bind
Initially bind are created when the network is deployed.
To create a bind, a person places the device in the environment and connects it to the ZigBee network. Then, they tell the APS to create a bind between the two devices.

## BIND and UNBIND primitives
* BIND: BIND.request creates a new entry in the local binding table, taking in the input table: \<source address, source endpoint, cluster identifier, destination address, destination endpoint\>.
* UNBIND: UNBIND.request deletes an entry from the local binding table


# Indirect addressing

Done using the binding table:
1) match source addr : \<network addr, endpoint addr\> and cluster identifier into the pair: 
	1) \<destination endpoint, destination network addr\>
## The binding table:
it is:
* stored in the APS of the ZigBee coordinator and of the router.
* it is updated on explicit request of **the ZDO in the routers or in the coordinator**
* it is usually initialise at network deployment


****

When an APO generates a message with a given cluster, the coordinator retrieves information from the binding table, including the:
* network address, endpoint of the source and clusterID of the message ("cluster")
Then, the coordinator uses this information to locate the destination device's network address and endpoint.

The binding table includes MAC addresses (IEEE address of 63 bits.), and the APS uses network addresses and map addresses to create a mapping between them. Ultimately, the mapping is done using the MAC address.


![[Pasted image 20230310175057.png]]

To retrieve the Source and Destination MAC addresses mapping to their Network addresses, we need the
**APS address MAP**
![[Pasted image 20230310232556.png]]
## APS address map
The map table is contained in the APS layer, it associates:
* 16 bit NWK(network) addresses with the 64 bit IEEE MAC addresses
**Zigbee end devices (ZED)** may change their 16 bit NWK addresses when they leave or join the network. If this happens the announcement is sent to the network and every nodes updates its internal tables accordingly to preserve the binding.


1) find a match for src addr
2) make a match for cluster id
3) make a match for source endpoint
4) then forward the messages to 3 destination 1 mac address (1 and dest ep 12), then 4 destination and dest ep 33.
If you specify dest addr 0x9999 you use multicast, to a group. Then you have another table with all the device in the broadcast.


### Incoming message.

The APS coordinator will obtain the MAC address and endpoint, then determine the network address before forwarding to the destination's network address.

When the coordinator receives the message, it includes the source network address, source endpoint, and cluster identifier.

The coordinator identifies the destination endpoint and network address by searching for the MAC address of the source in the Binding table. If a line match is found with the MAC address of the source, source endpoint, and cluster ID, the coordinator extracts the destination MAC address and endpoint.

However, the coordinator cannot use the destination MAC address alone and must consult the APS address map to determine the destination network address.

Once the network address is identified, the local network layer of the coordinator is instructed to send the message to the destination endpoint at that network address.

# Exercise
At the start, routers create a mapping between MAC addresses and network addresses, then we got the table with the mappings to use at time t.
![[Pasted image 20230310215453.png]]
Solution
1) 0000, 34
2) No message delivered as 0x0022 is disconnected
3) Message sent to  NWK Addr: 0x0001 and Dest EP: 
4) Message sent to 0x0003.

0000 is also the coordinator in ZigBee.


# ZDO

The ZDO implements the functionalities needed for any ZigBee devices. It is connected to endpoint 0 and implements:
* clusters for ZigBee
* in the ZigBee Device profile

Some of the functions are the device discovery functions.
There can be many devices in the enviroment, but you do not know what they are doing, so:
* mechanism to spot who are the device and how they describe themself.
Query the coordinator of the network, with a list of what are the devices that are placed.
This information it gets:
* network address of the device in a network. 

Over this there is a mechanism of **service discovery**, which should be used to get the full information about the network, where the network is created with a *parent/child building, as a tree, and the adresses are assigned according to the position on a tree.*
You respond to a network coordinator in the network, and the network coordinator knows about the parents (routers), but not about devices in the routers (which are its child).
The router child will respond based on its subtree. The routers will respond to the device discovery.
Then the person asking for network discovery will get the list of devices.

Then ask to the devices:
* **Service discovery***: directed to coordinator to get all services in a network
* directed to a single device, to find the services it offers.
Add the clusters to which the device will respond.

*To query an end device, its parent router will respond.* As the end device may be in power save mode, so the parent router will respond on behalf of it.

There may be some functionalities, such as flash, that allow to locate physically a device.
The ZDO may implement service discovery and the device discovery, forwarding the query to the ZDO of the routers.

The ZDO will also implement binding mechanism. The ZDO acts as a control layer that governs
the behavior and interactions of a Zigbee device within a Zigbee network.

APO may be local or one of your end device.

Message if cluster ID 4 and Endpoint 5, matches the second line, and it will match the device
with network adres O796F.

The message with Cluster ID 4 from endpoint 3 will match with line 1 and 4.

When you have 0x9999 **you send a multicast message, using the multicast function of the cluster library**.


# ZigBee Cluster Library

The cluster library defines the behaviours for multiple devices, *to have interoperability*.
This makes the device compatible at application level, as we want the device to be able to use each other (thermometer and thermostat for example).
Look at the cluster library before reinventing the wheel to implement a function.
![[Pasted image 20230314114126.png]]
Behaviours defined.


The cluster library use the paradigm:
* client: client that can read a value or **write an attribute on it**.
* server: sensors usually, which as an internal state

The server is basically a more complicated device, reading and writing a state.
![[Pasted image 20230314114306.png]]


### Functional domains
General: same for all domains
Closures
HVAC: pump system and cooling
Lighting
Measurement and sensing
Security and safety: description of the behaviours of the sensor for an alarm, such as a passive infrared
Protocol interfaces: made to ensure interoperability with other ZigBee protocol.

Commands: are messages at application layer, with an header and a payload.
The second is a parameter to the header.
e.g.: write(header) 1234(payload).

Commands can used about dynamic attribute reporting.
The server will for example return the temperature every X minutes.

There are commands to configure a periodic report.


#### Configuration commands
![[Pasted image 20230314114741.png]]
1) get basic information.
2) get power configuration.
3) Setup and read the temperature configuration, setting up alarms and behaviours to iti
4) Identify: flash a led function to make a human operator identify physically.

A configuration can be arbitrarily complex.
e.g. when having multiple lamps, with a dimmable one:
![[Pasted image 20230314114958.png]]
Place those in the environment and setup parameters, using a configuration tool. In this we setup the switches.
Setting up if a device is a router or a coordinator, or some other device is.
One ask to the coordinator to setup the binding between Dimmer Switch and Dimmable lamp and *what are the APO responding to On/Off and level control*.

To do so: on the configuration to have:
* define discovery
* service discovery
* identify
Then you have all the information to give to the binding table.
You may need multiple identifiers if you have more dimmable lamps.


The version of the ZigBee cluster library is mandatory, as we query to which device the application responds. So you need to get the specific cluster version. 

Mandatory/optional defines if it is obligatory to define the cluster library.

Power source= if it is on battery or plugged.

There are also for the attributes their type, if they are read only and if they have a default value.

So to get power source:
* basic cluster -> requesting for reading the power source

Temperature measurement cluster:
* it can be a reading and reporting with RO
* While the min and  measured values are only R.
We see there that the type are int16, so the thermometer is home automation, so they are less sophisticated.
Other systems industrial may have more precision.

### Temperature measurement cluster

It provides, read write, discovery and configure and report.
Any other cluster may provide functionalities to find each functionalities.

In general clusters are not a library, but allow to build increasingly complex applications. Or a lamp with colors and manufacturer specific features.
*Rather than defining libraries for all the possible lamp in the world, add more and more cluster to have all the possible behaviour.*
![[Pasted image 20230314120033.png]]

Also with manufacturer features, allow to have those, which will not be used by device of other manufacturer but at least the device are available.

If you are a company specialized in systems, with components integrated among themselves to make something more complex.
So when creating an IoT solution, buy HW from providers and see them.
See the implementation of the ClusterLibrary as a support.
Add sensor and actuators depending on your need, putting them into shells, then implement the APO and so setup the business logic of the device, then you are ready to go in the market.

If making a deployment to a customer, have your own deployments using configuration tools and complex things, spending less in other internal mechanism of the devices.
Add the software which makes you in a simple way pair your devices.


# ZigBee security

Security is not built in, but is optional.
It is light enough that device can afford it.
The security services include the four elements:
* key establishment (Authentication + mechanism of integraty done with keys/hashes): you need to provide and exchange to devices the keys, enabling the security mechanism
* key transport
* frame protection: use the keys to create frame encryption and integrity
* device management: device management mechanism

ZigBee makes several assumptions that limits the bahavior of the intruders.
As it assumes:
* device can keep in a safe place the keys
* There is a protection mechanism employed
* trust to someone that gives you the keys

Trust that the installation is secure, and so not compromising a secure network.

Suppose that:
* all security protocols were correctly implemented
* correct random generator, as it creates the key for encryption. Note that the ZigBee standard gives the specification, not the implementation
So implement correctly, deploy correctly, add limitations to intruders.

ZigBee suppose that the protection operates to the device level and network level.
The level of protection is the entire device.
For example on a PC, there may be multiple user, and if one is affected by weak password, the other may be safeguarded by the PC. 
The latter is not true here.

Those security mechanism are not resilient to the tampering of devices.
If someone takes them and tampers with them then it may compromise it.

The specification does not tell anything, but one could try to mechanism with anti tamper to protect it.

If there is tampering, then there may be ways to find it.


### Security Design Choice

* A single key: can operate with just one key for the whole network
* single key per link, end to end

The protection of the frame, is implemented at the network layer.
The APS provides the key to the network layer.
The ZDO provides the key to the APS.


The application profiles provides the cluster and specification to allow to connect to a secure network in a secure way, and obtain the encryption material.
The standard also has mechanism to detect that something were wrong, misuses of keys etc.**Allowing to re-synchronize keys and reestablish the network functions**.


ZDO, manages the security policy and configuration. Then the APS sets that up in the network layer.


## Keys

Both link or network keys can be obtained :
1) by transport: asking for it to a device centralized. It may be a problem, as you do not have a key, and so you must receive the key without encryption. This can be ok if you are in a place without anyone else there. 
2) key establishment: use protocols to generate keys
3) Pre-installation: the manufacturer insert the keys in the device
There is another key:
**Master key**: it can be used to create other keys, eg pre installed.
The device then uses it to generate new keys 
(diff helman). It allows us to obtain a link key or network key

Eg combine random number with master key pre installed.

# Trust-center
It may be implemented in the coordinator or have an ad-hoc functionality.
The trust center is the device trusted by the rest of the network, which allows to get keys, both network or link keys.

After you join a network you connect to it and then it allows us to communicate in the network.